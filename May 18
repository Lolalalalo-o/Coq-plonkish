(*May 18, Chapter 4*)
Fixpoint filter {X:Type} (test: X -> bool) (l : list X) : (list X) :=
  match l with
  | [] => []
  | h :: t => if test h then h :: (filter test t) else filter test t
  end.
(*annoying Datatypes
Definition filter_even_gt7 (l : list nat) : list nat :=
  filter (fun n => andb (evenb n) (le 7 n)) l.  

Definition partition {X : Type} (test : X -> bool) (l : list X) : list X * list X :=
  (filter test l , filter (fun x => negb (test x)) l).

Example test_partition1: partition oddb [1;2;3;4;5] = ([1;3;5],[2;4]).
Example test_partition2: partition (fun x => false) [5;9;0] = ([],[5;9;0]).*)

Fixpoint map {X Y : Type} (f: X -> Y) (l : list X) : (list Y) :=
  match l with
  | [] => []
  | h :: t => (f h) :: (map f t)
  end.
Example test_map1: map (fun x => plus 3 x) [2;0;2] = [5;3;5].
 reflexivity. Qed.

Fixpoint evenb (n:nat) : bool :=
  match n with
  | O => true
  | S O => false
  | S (S n') => evenb n'
  end.
Definition oddb (n:nat) : bool := negb (evenb n).
Example test_map2:
  map oddb [2;1;2;5] = [false;true;false;true].
reflexivity. Qed.
Example test_map3:
  map (fun n => [evenb n; oddb n]) [2;1;2;5] = [[true;false];[false;true];[true;false];[false;true]].
reflexivity. Qed.

Fixpoint rev' {X : Type} (l : list X) : list X:=
  match l with
  | nil => nil
  | h :: t => (rev' t) ++ [h]
  end.

Lemma map_assoc : forall (X Y : Type) (f: X -> Y) (l1 l2 : list X),
  map f (l1 ++ l2) = (map f l1) ++ (map f l2).
Proof. intros X Y f l1 l2. induction l1 as [| l1'].
  - reflexivity.
  - simpl. rewrite IHl1. reflexivity. Qed.
Theorem map_rev : forall (X Y:Type) (f : X -> Y) (l : list X),
  map f (rev' l) = rev' (map f l).
Proof. intros X Y f l. induction l as [| l'].
  - reflexivity.
  - simpl. rewrite map_assoc. rewrite IHl. simpl. reflexivity. Qed.

Fixpoint fold {X Y : Type} (f : X -> Y -> Y) (l : list X) (b : Y) : Y :=
  match l with
  | nil => b
  | h :: t => f h (fold f t b)
  end.
Check (fold andb).
Example fold_example1 : fold mult [1;2;3;4] 1 = 24.
  reflexivity. Qed.
Example fold_example2 :
  fold app [[1];[];[2;3];[4]] [] =[1;2;3;4].
reflexivity. Qed.

Definition constfun {X : Type} (x : X) : nat -> X :=
  fun (k:nat) => x. 
Definition ftrue := constfun true.
Example constfun_example1 : ftrue 0 = true.
reflexivity. Qed.
Example constfun_example2 : (constfun 5) 99 = 5.
  Proof. reflexivity. Qed.
Definition plus3 := plus 3.
Check plus3.
Example test_plus3 : plus3 4 = 7. reflexivity. Qed.
Module Exercises.
Definition fold_length {X : Type} (l : list X) : nat :=
  fold (fun _ n => S n) l 0.
Example test_fold_length : fold_length [4;7;0] =3. reflexivity. Qed.

Theorem fold_length_correct : forall X (l : list X),
  fold_length l = length l.
Proof.
  intros X l. induction l as [| l']. 
    - reflexivity.
    - simpl. rewrite <- IHl. reflexivity. Qed.
Check fold_length_correct.
Definition prod_curry {X Y Z : Type} (f : X * Y -> Z) (x : X) (y : Y) : Z := f(x, y).

Definition prod_uncurry {X Y Z : Type} (f : X -> Y -> Z) (p : X * Y) : Z := f (fst p) (snd p).

Require Import Coq.Logic.FunctionalExtensionality.

Theorem prod_uncurry_curry : forall (X Y Z : Type) (f : X * Y -> Z), prod_uncurry (prod_curry f) =f.
Proof. intros X Y Z f. extensionality p. destruct p. reflexivity. Qed.

Theorem prod_curry_uncurry : forall (X Y Z : Type) (f : X -> Y -> Z)(p : X * Y), prod_curry (prod_uncurry f) = f.
Proof. intros X Y Z f p. reflexivity. Qed.

Example test_mapl' : map (plus 3) [2;0;2] = [5;3;5]. reflexivity. Qed.
Check @prod_curry : forall X Y Z : Type, (X*Y -> Z) -> X -> Y -> Z.
Check @prod_uncurry : forall X Y Z : Type, (X -> Y -> Z) -> (X * Y) -> Z.
Theorem uncurry_curry : forall (X Y Z : Type) (f : X -> Y -> Z) x y,
  prod_curry (prod_uncurry f) x y = f x y.
Proof. intros X Y Z f x y.  unfold prod_curry. unfold prod_uncurry. simpl. reflexivity. Qed.
Theorem curry_uncurry : forall (X Y Z: Type) (f : (X * Y) -> Z) (p : X * Y),
  prod_uncurry (prod_curry f) p = f p.
Proof. intros X Y Z f p. rewrite prod_uncurry_curry. reflexivity. Qed.
End Exercises.

Module Church.
Definition cnat := forall X : Type, (X -> X) -> X -> X.
Definition one : cnat :=
fun (X : Type) (f : X -> X) (x: X) => f x.
Definition two : cnat:=
  fun (X : Type) (f : X -> X) (x: X) => f (f x).
Definition zero : cnat :=
  fun (X : Type) (f : X -> X) (x : X) => x.

Definition three : cnat:=
  fun (X : Type) (f : X -> X) (x: X) => f (f (f x)).

Definition succ (n : cnat) : cnat :=
  fun (X : Type) (f : X -> X) (x : X) => f (n X f x).

Example succ_l : succ zero = one.
Proof. reflexivity. Qed.

Definition plus (n m : cnat) : cnat :=
  fun (X : Type) (f : X -> X) (x : X) => n X f (m X f x).

Example plus_1 : plus zero one = one.
Proof. reflexivity. Qed.

Example plus_2 : plus two three = plus three two.
Proof. reflexivity. Qed.

Example plus_3 : plus (plus two two) three = plus one (plus three three).
Proof. reflexivity. Qed.
Check plus.
Check succ.

Definition mult (n m : cnat) : cnat :=
  fun (X : Type) (f : X -> X) (x : X) => n X (m X f) x.

Example mult_1 : mult one one = one. reflexivity. Qed.

Example mult_2 : mult zero (plus three three) = zero. reflexivity. Qed.

Example mult_3 : mult two three = plus three three. 
Proof. unfold mult. unfold plus. reflexivity. Qed.

Check mult.

End Church.
