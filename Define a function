(* Compilation pass*)
Inductive natlistL : nat -> Type :=
  | nilL : natlistL O
  | consL: forall {n : nat} , natlistL n -> natlistL (S n).
(* error: The term "2" has type "nat" while it is expected to have type "natlistL ?n". *)
Example example_list : natlistL 3 :=
  consL 2 (consL 9 (consL 0 nilL)).
(* Compilation pass*)
Inductive matrix : nat -> nat -> Type :=
  | nilM : matrix O O
  | consM: forall {m n : nat} , natlistL n -> matrix m n -> matrix (S m) n.
(* error: m, n : nat should be a name*)
Definition function : Type := {(m, n : nat) & (matrix m n)}.
(* May 12 *)
Definition function := natlist.

Fixpoint f_add (f1 f2 : function) : function :=
  match f1, f2 with
  | nil, nil => nil
  | nil, h :: t => f2
  | h :: t, nil => f1
  | h1 :: t1, h2 :: t2 => (h1 + h2) :: f_add t1 t2
  end.

Definition f1 := cons 1 (cons 2 (cons 3 nil)).
Definition f2 := cons 2 (cons 3 (cons 4 nil)).

Example test_f_add: f_add f1 f2 = [3;5;7].
Proof. reflexivity. Qed.

Fixpoint f_mult (f1 f2 : function) : nat :=
  match f1, f2 with
  | nil, nil => O
  | nil, h :: t => O
  | h :: t, nil => O
  | h1 :: t1, h2 :: t2 => h1 * h2 + f_mult t1 t2
  end.
  
Example test_f_mult: f_mult f1 f2 = 20.
Proof. reflexivity. Qed.
