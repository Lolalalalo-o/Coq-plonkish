(* Compilation pass*)
Inductive natlistL : nat -> Type :=
  | nilL : natlistL O
  | consL: forall {n : nat} , natlistL n -> natlistL (S n).
(* error: The term "2" has type "nat" while it is expected to have type "natlistL ?n". *)
Example example_list : natlistL 3 :=
  consL 2 (consL 9 (consL 0 nilL)).
(* Compilation pass*)
Inductive matrix : nat -> nat -> Type :=
  | nilM : matrix O O
  | consM: forall {m n : nat} , natlistL n -> matrix m n -> matrix (S m) n.
(* error: m, n : nat should be a name*)
Definition function : Type := {(m, n : nat) & (matrix m n)}.
(* May 12 *)
Definition function := natlist.

Fixpoint f_add (f1 f2 : function) : function :=
  match f1, f2 with
  | nil, nil => nil
  | nil, h :: t => f2
  | h :: t, nil => f1
  | h1 :: t1, h2 :: t2 => (h1 + h2) :: f_add t1 t2
  end.

Definition f1 := cons 1 (cons 2 (cons 3 nil)).
Definition f2 := cons 2 (cons 3 (cons 4 nil)).

Example test_f_add: f_add f1 f2 = [3;5;7].
Proof. reflexivity. Qed.

Fixpoint f_mult (f1 f2 : function) : nat :=
  match f1, f2 with
  | nil, nil => O
  | nil, h :: t => O
  | h :: t, nil => O
  | h1 :: t1, h2 :: t2 => h1 * h2 + f_mult t1 t2
  end.
  
Example test_f_mult: f_mult f1 f2 = 20.
Proof. reflexivity. Qed.

Notation "x ** y" := (f_mult x y)
                     (at level 20).

Definition f3 := cons 0 (cons 1 (cons 2 nil)).
Definition f4 := f3.

Example test_f_mult1 : f1 ** f2 + f3 ** f4 = 25.
Proof. reflexivity. Qed.

Theorem simple_example : 2 + 2 = 4.
Proof.
  exact (eq_refl 4).
Qed.
Check eq_refl.

Lemma FOT : False -> True.
  exact (fun (H : False) => I).
Qed.

Lemma false_imply_true:
  False -> True.
Proof.
  apply (fun (H : False)=> match H with end).
Qed.

Module Field.

(*Inductive Field : Set :=
  | nilF : Field
  | consF : nat -> Field.*)
Require Import Coq.Init.Nat.
Require Import Coq.Vectors.Vector.
Import VectorNotations.

(*Definition smallerThan (p : nat) : Prop := exists n, n < p.

Definition Field : Set := { p : nat | smallerThan p }.

(* 构造一个包含所有小于5的自然数的Field实例 *)
Definition field_5 : Vector.t Field 5.
Proof.
  refine (exist _ 1 _ :: exist _ 2 _ :: exist _ 3 _ :: exist _ 4 _ :: exist _ 5 _ :: @nil Field).
  - exists 0. apply Nat.lt_succ_diag_r.
  - exists 1. apply Nat.lt_succ_diag_r.
  - exists 2. apply Nat.lt_succ_diag_r.
  - exists 3. apply Nat.lt_succ_diag_r.
  - exists 4. apply Nat.lt_succ_diag_r.
Defined.*)

Definition smallerThan (p : nat) : Prop := exists n, n < p.

Definition Field : Set := { p : nat | smallerThan p }.
Definition field : Field.
Proof.
  exists 1. exists 0. apply Nat.lt_succ_diag_r.
Defined.
Check field. 

Inductive Poly : Set :=
| Scalar: Field -> Poly
| Map: (Field -> Field) -> Poly
| Add: Poly -> Poly -> Poly (*a + b*)
| Mul: Poly -> Poly -> Poly (*a * b*)
| Shift: Poly -> nat -> Poly (*f(x + s)*)
| Scale: Field -> Poly -> Poly. (*s * f(x)*)

Notation "x + y" := (Add x y).
Notation "x * y" := (Mul x y).

Inductive Constraint: Set :=
| IsZero: Poly -> Constraint (*f(x) = 0; 3f(x) = 0*)
| lookup: Poly -> Poly -> Constraint (*forall x, exists y, f(x) = g(x)*)
| Shuffle: Poly -> Poly -> Constraint. (*f(x) = g(x)*)

Definition f := Scalar (field).
Definition g := Scalar (field).
Definition z := Scalar (field).
Definition f1 := Map (fun x => field). 
Definition g1 := Map (fun x => field).

Definition C1 := IsZero (f + g + (Scale field z)).
Definition C2 := Shuffle (Scale field f) ((Scale field g) + (Scalar field)).
Definition C3 := lookup f1 ((Scalar field) + g1).
End Field.
