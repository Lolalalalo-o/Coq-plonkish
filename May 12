Definition function := natlist.

Fixpoint f_add (f1 f2 : function) : function :=
  match f1, f2 with
  | nil, nil => nil
  | nil, h :: t => f2
  | h :: t, nil => f1
  | h1 :: t1, h2 :: t2 => (h1 + h2) :: f_add t1 t2
  end.

Definition f1 := cons 1 (cons 2 (cons 3 nil)).
Definition f2 := cons 2 (cons 3 (cons 4 nil)).

Example test_f_add: f_add f1 f2 = [3;5;7].
Proof. reflexivity. Qed.

Fixpoint f_mult (f1 f2 : function) : nat :=
  match f1, f2 with
  | nil, nil => O
  | nil, h :: t => O
  | h :: t, nil => O
  | h1 :: t1, h2 :: t2 => h1 * h2 + f_mult t1 t2
  end.
  
Example test_f_mult: f_mult f1 f2 = 20.
Proof. reflexivity. Qed.

Notation "x ** y" := (f_mult x y)
                     (at level 20).

Definition f3 := cons 0 (cons 1 (cons 2 nil)).
Definition f4 := f3.

Example test_f_mult1 : f1 ** f2 + f3 ** f4 = 25.
Proof. reflexivity. Qed.

Theorem count_member_nonzero : forall (s:bag),
  1 <=? (count 1 (1 :: s)) = Datatypes.true.
Proof.
  intros s. reflexivity. Qed.

Theorem leb_n_Sn : forall n,
  n <=? (S n) = Datatypes.true.
Proof.
  intros n. induction n as [| n' IHn'].
  - simpl. reflexivity.
  - simpl. rewrite -> IHn'. reflexivity. Qed.

Theorem remove_does_not_increase_count : forall (s : bag),
  (count 0 (remove_one 0 s)) <=? (count 0 s) = Datatypes.true.
Proof. induction s as [| n s' IHs'].
  - reflexivity.
  - destruct n as [| n'] eqn:E.
    + simpl. rewrite -> leb_n_Sn. reflexivity.
    + simpl. rewrite -> IHs'. reflexivity. Qed.

Theorem rev_is_injective : 
  forall (l1 l2 : natlist), rev l1 = rev l2 -> l1 = l2.
Proof.
  intros l1 l2. induction l1 as [| n l1' IHl1'].
  - simpl. Search rev. induction l2 as [|m l2' IHl2'].
    + reflexivity.
    + simpl. rewrite -> IHl2'. Search rev. Abort.

Search hd_error.

Inductive natoption : Type :=
  | Some ( n : nat)
  | None.

Definition hd_error (l : natlist) : natoption :=
  match l with
  | nil => None
  | h :: t =>Some h
  end.

Example test_hd_error1 : hd_error [] =None.
 reflexivity. Qed.
Example test_hd_error2 : hd_error [1] = Some 1.
  reflexivity. Qed.
Example test_hd_error3 : hd_error [5;6] = Some 5.
  reflexivity. Qed.

Inductive id : Type :=
| ID (n:nat).

Definition eqb_id (x1 x2 : id) :=
  match x1, x2 with
  | ID n1, ID n2 => n1 =? n2
  end.

Theorem eqb_id_refl : forall x, Datatypes.true = eqb_id x x.
Proof. 
  intros x. 
  unfold eqb_id. destruct x as [n].
  rewrite -> Nat.eqb_refl. reflexivity. Qed.

Module PatrialMap.
Inductive partial_map : Type :=
  | empty
  | record (i : id) (v : nat) (m : partial_map).
Definition update (d : partial_map)
                  (x : id) (value : nat)
                  : partial_map :=
  record x value d.
Fixpoint find (x : id) (d : partial_map) : natoption :=
  match d with
  | empty => None
  | record y v d' => if eqb_id x y then Some v else find x d'
end.

Theorem update_eq :
  forall (d : partial_map) (x : id) (v : nat),
    find x (update d x v) = Some v.
Proof.
  intros d x v. simpl. rewrite <- eqb_id_refl. reflexivity. Qed.

Inductive baz : Type :=
  | Baz1 (x : baz)
  | Baz2 (y : baz) (b : bool).

Theorem mult_1 : forall m n : nat,
  n+n*m=n*(1+m).
Proof.
  induction n as [| n' IHn'].
  - reflexivity.
  - simpl. rewrite -> plus_swap. rewrite -> IHn'. simpl. reflexivity. Qed. 


Theorem mult_comm : forall m n : nat,
  m * n = n* m.
Proof.
  intros m n. induction m as [| m' IHm'].
  - simpl. induction n as [| n' IHn'].
    + reflexivity.
    + simpl. rewrite <- IHn'. reflexivity.
  - simpl. rewrite -> IHm'. rewrite -> mult_1. reflexivity. Qed.

Check leb.
Theorem leb_refl : forall n:nat,
  Datatypes.true = (n<=? n).
Proof. induction n as [| n' IHn']. 
  - reflexivity.
  - simpl. rewrite IHn'. reflexivity. Qed.

Theorem zero_nbeg_S : forall n:nat,
  0 =? (S n) = Datatypes.false.
Proof.
  intros n. reflexivity. Qed.

Theorem andb_false_r : forall b:Datatypes.bool,
  andb b Datatypes.false = Datatypes.false.
Proof. 
 intros b. destruct b eqn:Hb.
  - reflexivity.
  - reflexivity. Qed.

Theorem plus_ble_compat_l : forall n m p : nat,
  n <=? m = Datatypes.true -> (p+n) <=? (p+m) =Datatypes.true.
Proof.
  intros n m p H. induction p as [| p' IHp'].
  - simpl. rewrite -> H. reflexivity.
  - simpl. rewrite -> IHp'. reflexivity. Qed.

Theorem S_nbeq_0 : forall n:nat,
  (S n) =? 0 = Datatypes.false.
Proof. intros n. reflexivity. Qed.

Theorem mult_l_ : forall n:nat, 1 * n = n.
Proof. intros n. simpl. induction n as [| n' IHn'].
  - reflexivity.
  - simpl. rewrite -> IHn'. reflexivity. Qed.

Theorem mult_plus_distr_r : forall n m p : nat,
  (n+m)*p =(n*p)+(m*p).
Proof.
  intros n m p. induction n as [ | n' IHn'].
  - simpl. reflexivity.
  - simpl. rewrite IHn'. rewrite Nat.add_assoc. reflexivity. Qed.

Theorem mult_assoc : forall n m p : nat,
  n * (m * p) = (n * m) * p.
Proof. 
  intros n m p. induction n as [| n' IHn'].
  - simpl. reflexivity.
  - simpl. rewrite IHn'. rewrite mult_plus_distr_r. reflexivity. Qed.

Theorem eqb_refl : forall n : nat,
  Datatypes.true = (n =? n).
Proof.
  intros n. induction n as [| n' IHn'].
  - simpl. reflexivity.
  - simpl. rewrite IHn'. reflexivity. Qed.

Theorem plus_swap' : forall n m p : nat,
  n + (m + p) = m + (n + p).
Proof.
  intros n m p. rewrite Nat.add_comm. replace (n+p) with (p+n). rewrite plus_assoc'. 
  reflexivity. rewrite Nat.add_comm. reflexivity. Qed.

Fixpoint incr (m:bin) : bin :=
  match m with
  | z => B z
  | A n => B n
  | B n => A (incr n)
  end.

Fixpoint bin_to_nat (b : bin) : nat :=
  match b with
  | z => 0
  | A n => 2*(bin_to_nat n-1)
  | B n => 2*(bin_to_nat n) +1
  end.
Example test_bin_to_nat : bin_to_nat (B (B z)) = 3.
Proof. reflexivity. Qed.

Theorem bin_to_nat_pres_incr : forall b : bin,
  bin_to_nat(incr b) = S(bin_to_nat b).
Proof. destruct b as [| n | n] eqn:E.
  - simpl. reflexivity.
  - unfold incr. simpl. rewrite Nat.add_assoc. Abort.
